# Доопределение блоков на проектном уровне

## Атрибут `readonly`

### Доопределение BEMHTML-шаблона

Если вам понадобилось запретить редактирование содержимого блока `input`, то нужно делать следующее.
Всем известно, что в HTML для этого используется атрибут `readonly`. Однако, в `bem-components` у блока `input` нет возможности указывать атрибуты контрола напрямую. Это сделано потому, что мы поддерживаем стабильную версию библиотеки, где все работает во всех заявленных браузерах.
Вполне логично выразить наличие этого атрибута модификатором `_readonly`.
Создадим на проектном уровне `common.blocks` папку `input/_readonly/`. Туда мы положим файл `input_readonly.bemhtml`:

```js
/* /common.blocks/input/_readonly/input_readonly.bemhtml */

block('input').mod('readonly', true)(
    elem('control').attrs()(function() {
        return this.extend(applyNext(), { readonly : '' });
    })
);
```

Этот шаблон доопределяет библиотечный шаблон блока. Нам нужно добавить атрибут `readonly=""` HTML-тэгу `input`, с помощью которого реализован блок. Этот тэг представлен элементом `control`. Это значит, что нам нужно доопределить шаблон, задающий HTML-атрибуты этого элемента.
Мы используем конструкцию `applyNext()` для того, чтобы получить результат выполнения библиотечного шаблона, который строит HTML-атрибуты контрола на основе входных данных. Этот шаблон возвращает объект, который описывает атрибуты. Таким образом, нам остается лишь дополнить этот объект свойством `readonly` со значением `''` (пустая строка). Для этого мы используем хелпер `this.extend`, доступный в BEMHTML. Он работает аналогично `jQuery.extend`, т.е. просто объединяет два объекта в один. Таким образом, в результате выполнения этих двух шаблонов мы получим набор атрибутов, среди которых будет `readonly=""` - это то, что мы хотели.
Теперь, если нам нужно добавить на страницу текстовое поле, доступное только для чтения, мы можем использовать блок `input` с атрибутом `readonly`:

```js
{
    block: 'input',
    mods: {
        theme: 'islands',
        size: 'm',
        readonly: true
    }
}
```

### Доопределение клиентского JS

Допустим, логика работы нашего приложения такова, что необходимо в определенный момент добавить или убрать атрибут `readonly=""`. Для этого нам потребуется доопределить поведение блока, определенное в файле `input.js`. Мы хотим расширить API блока таким образом, чтобы можно было управлять наличием атрибута с помощью установки/снятия модификатора. Сделать это очень просто:

 ```js
/* /common.blocks/input/_readonly/input_readonly.js */

modules.define('input', function(provide, Input) {

provide(Input.decl({
    onSetMod : {
        readonly : function(modName, modVal) {
            modVal?
                this.elem('control').attr('readonly', '') :
                this.elem('control').removeAttr('readonly');
        }
    }
}));

});
 ```

Мы декларируем модуль `input`, который представлен BEM-блоком. Т.к. этот блок уже есть в библиотеке, функция-декларатор модульной системы получает вторым аргументом класс блока `Input`. У него есть метод `decl`, который доопределяет поведение блока. В секции `onSetMod` мы определяем реакцию на изменение модификатора `_readonly`. Внутри обработчика на изменение модификатора используются jQuery-хелперы для управления HTML-атрибутами. Значениями аргумента `modVal` будут `true` и `false` при установке и снятии модификатора соотвественно.
Теперь мы можем управлять наличием атрибута `readonly` с помощью модификатора:

```js
var input = $('.input').bem('input');

input.setMod('readonly'); // добавляем атрибут
input.delMod('readonly'); // удаляем атрибут
```

