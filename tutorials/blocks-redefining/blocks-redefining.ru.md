### Доопределение блоков на проектном уровне

Любой блок &mdash; абстракция над реализацией некой функциональности в различных технологиях, таких как HTML, CSS или JS. Иначе говоря, блок инкапсулирует реализацию определенного функционала и предоставяет высокоуровневое API, описанное в документации. Реализация той или иной функциональности находится в шаблонах, скриптах и стилевых файлах блока на уровне библиотеки. В общем случае от разработчика не требуется знания внутреннего устройства и подробностей реализации блока. Достаточно использовать возможности блока, руководствуясь документацией. Но иногда бывает так, что базовых возможностей, предоставляемых компонентами библиотеки, недостаточно.

#### Атрибут `readonly`

Допустим, требуется создать текстовое поле, доступное только для чтения. В HTML для этого используется тэг `input` с атрибутом `readonly`:

 ```html
 <input readonly="" />
 ```

 В `bem-components` для создания текстовых полей служит блок `input`. Он реализован с помощью HTML-тэга `input`, но API блока не позволяет управлять наличием нужного атрибута или указывать произвольные атрибуты контрола напрямую. Как уже говорилось выше, в БЭМ любая функциональность может быть представлена БЭМ-сущностью. Вполне логично выразить наличие нужного атрибута модификатором `_readonly` блока `input`.

##### Доопределение BEMHTML-шаблона

Для описания HTML-представления служит шаблонизатор. В библиотеке есть несколько шаблонов, в которых определена логика формирования HTML для блока `input`. Для того, чтобы доопределить эту логику, вовсе не обязательно редактировать шаблоны библиотеки. Достаточно создать на уровне проекта дополнительные шаблоны, которые будут доопределять библиотечные.

Создадим на проектном уровне `common.blocks` папку `input/_readonly/` и положим туда файл `input_readonly.bemhtml`:

```js
/* /common.blocks/input/_readonly/input_readonly.bemhtml */

block('input').mod('readonly', true)(
    elem('control').attrs()(function() {
        var attrs = applyNext();
        attrs.readonly = '';
        return attrs;
    })
);
```

Этот шаблон доопределяет библиотечный шаблон блока. Требуется добавить атрибут `readonly` HTML-тэгу `input`, с помощью которого реализован блок. Этот тэг представлен элементом `control`, поэтому нужно доопределить шаблон, задающий HTML-атрибуты для этого элемента.

Мы используем конструкцию `applyNext()` для того, чтобы получить результат выполнения библиотечного шаблона, который строит HTML-атрибуты контрола на основе входных данных. Этот шаблон возвращает объект, описывающий атрибуты контрола. В нашем шаблоне мы добавляем в этот объект атрибут `readonly`.

Теперь, если нам нужно добавить на страницу текстовое поле, доступное только для чтения, мы можем использовать блок `input` с модификатором `readonly`:

```js
// BEMJSON

{
    block : 'input',
    mods : {
        theme : 'simple',
        readonly : true
    }
}
```

##### Доопределение клиентского JS

Допустим, логика работы нашего приложения такова, что необходимо в определенный момент добавить или убрать атрибут `readonly`. Для этого нам потребуется доопределить поведение блока, определенное в файле `input.js`. Мы хотим расширить API блока таким образом, чтобы можно было управлять наличием атрибута с помощью установки/снятия модификатора. Сделать это очень просто:

 ```js
/* /common.blocks/input/_readonly/input_readonly.js */

modules.define('input', function(provide, Input) {

provide(Input.decl({
    onSetMod : {
        'readonly' : function(modName, modVal) {
            modVal?
                this.elem('control').attr('readonly', '') :
                this.elem('control').removeAttr('readonly');
        }
    }
}));

});
 ```

Мы декларируем модуль `input`, который представлен BEM-блоком. Т.к. этот блок уже есть в библиотеке, функция-декларатор модульной системы получает вторым аргументом класс блока `Input`. У него есть метод `decl`, который доопределяет поведение блока. В секции `onSetMod` мы определяем реакцию на изменение модификатора `_readonly`. Внутри обработчика на изменение модификатора используются jQuery-хелперы для управления HTML-атрибутами. Значениями аргумента `modVal` будут `true` и `false` при установке и снятии модификатора соотвественно.

Теперь мы можем управлять наличием атрибута `readonly` с помощью модификатора:

```js
var input = $('.input').bem('input');

input.setMod('readonly'); // добавляем атрибут
input.delMod('readonly'); // удаляем атрибут
```

Мы расширили внешнее API блока.

Для поддержки такой архитектуры достаточно гарантировать стабильность внутреннего устройства компонент в рамках мажорной версии.

