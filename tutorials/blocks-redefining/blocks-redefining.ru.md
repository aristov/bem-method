# Доопределение блоков на проектном уровне

## Атрибут `readonly`

### Доопределение BEMHTML-шаблона

В `bem-components` для создания текстовых полей служит блок `input`. Он реализован с помощью тэга `input`, но API блока не позволяет указывать произвольные атрибуты напрямую. Дело в том, что любой блок - это абстракция над реализацией его функциональности в HTML, CSS и JS. Иначе говоря, БЭМ-блок инкапсулирует реализацию определенного функционала в различных технологиях и предоставяет высокоуровневое API, описанное в документации. Подробности реализации той или иной функциональности находятся в шаблонах, скриптах и стилевых файлах блока на уровне библиотеки. Иногда возникает ситуация, когда возможностей, предоставляемых компонентами библиотеки недостаточно. Например, требуется создать текстовое поле, доступное только для чтения. В HTML для этого используется тэг `input` с атрибутом `readonly`. Вполне логично выразить наличие этого атрибута модификатором `_readonly`.
Создадим на проектном уровне `common.blocks` папку `input/_readonly/`. Туда мы положим файл `input_readonly.bemhtml`:

```js
/* /common.blocks/input/_readonly/input_readonly.bemhtml */

block('input').mod('readonly', true)(
    elem('control').attrs()(function() {
        return this.extend(applyNext(), { readonly : '' });
    })
);
```

Этот шаблон доопределяет библиотечный шаблон блока. Нам нужно добавить атрибут `readonly=""` HTML-тэгу `input`, с помощью которого реализован блок. Этот тэг представлен элементом `control`. Это значит, что нам нужно доопределить шаблон, задающий HTML-атрибуты этого элемента.
Мы используем конструкцию `applyNext()` для того, чтобы получить результат выполнения библиотечного шаблона, который строит HTML-атрибуты контрола на основе входных данных. Этот шаблон возвращает объект атрибутов контрола. Добавим в него атрибут `readonly`. Для объединения объектов используется хелпер `this.extend`, доступный в BEMHTML. Он работает аналогично `jQuery.extend`.
Теперь, если нам нужно добавить на страницу текстовое поле, доступное только для чтения, мы можем использовать блок `input` с атрибутом `readonly`:

```js
{
    block: 'input',
    mods: {
        theme: 'simple',
        readonly: true
    }
}
```

### Доопределение клиентского JS

Допустим, логика работы нашего приложения такова, что необходимо в определенный момент добавить или убрать атрибут `readonly=""`. Для этого нам потребуется доопределить поведение блока, определенное в файле `input.js`. Мы хотим расширить API блока таким образом, чтобы можно было управлять наличием атрибута с помощью установки/снятия модификатора. Сделать это очень просто:

 ```js
/* /common.blocks/input/_readonly/input_readonly.js */

modules.define('input', function(provide, Input) {

provide(Input.decl({
    onSetMod : {
        readonly : function(modName, modVal) {
            modVal?
                this.elem('control').attr('readonly', '') :
                this.elem('control').removeAttr('readonly');
        }
    }
}));

});
 ```

Мы декларируем модуль `input`, который представлен BEM-блоком. Т.к. этот блок уже есть в библиотеке, функция-декларатор модульной системы получает вторым аргументом класс блока `Input`. У него есть метод `decl`, который доопределяет поведение блока. В секции `onSetMod` мы определяем реакцию на изменение модификатора `_readonly`. Внутри обработчика на изменение модификатора используются jQuery-хелперы для управления HTML-атрибутами. Значениями аргумента `modVal` будут `true` и `false` при установке и снятии модификатора соотвественно.
Теперь мы можем управлять наличием атрибута `readonly` с помощью модификатора:

```js
var input = $('.input').bem('input');

input.setMod('readonly'); // добавляем атрибут
input.delMod('readonly'); // удаляем атрибут
```

